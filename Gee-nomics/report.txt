1. Not that I know of but I'm sure there's something. But it is still pretty slow at loading. And I
probably should have done swaps with the algorithm instead of doing it manually. But it works, so good
enough. 

2. Trie(), ~Trie(), Trie::reset(), Trie::insert(), Trie::find() (probably), Genome(), Genome::load(),
Genome::length(), Genome::name(), Genome::extract(), GenomeMatcher(), GenomeMatcher::addGenome(), 
GenomeMatcher::minimumSearchLength(), GenomeMatcher::findGenomesWithThisDNA()
^ As far as I can tell, these all work with the specified efficiency. I am slightly unsure about
Trie::find() for exactMatchOnly is false, however, but I also cannot think of a better algorithm to 
use, so I am pretty confident. 
As for my nemesis, findRelatedGenomes(), I am very unsure. The first for loop should be O(Q*N) since
the loop runs a fraction of Q times, and each time it calls findGenomesWithThisDNA() which is the N
part. I am not sure about the sorting. The sorting should be O(QlogQ)? The constant of proportionality
should be small, but if every single extracted sequence came from a different genome, this number could
get pretty big. I don't know if the O(QlogQ) can be disregarded because of the O(Q*N), but I don't
think so? So I'll just assume that I didn't meet this requirement. 

3. 
Trie::find()
- This one I had fun with. Wrote a helper function to do recursion
- in the helper function...
	- stopping condition, key is empty string
		- push all the values on the current node into vector v (finally), and return
	- if exactMatchOnly is true or this is the first char of a sequence (isFirst), then
		- run through the list of pointers to children nodes
		- if the label of a child is equal to the the first char of the key, do recursion with
			- substring of key starting from second char (because first char's match
			  was found at the child node)
			- exactMatchOnly, whatever original value it had
			- pointer to the correct child node (label is same as first char of key)
			- vector reference, to use at the very end
			- false for isFirst because after this run, the sequence won't be at the
			  first character
	- otherise, exactMatchOnly is false, so
		- run through the list of pointers to children nodes
		- if the label of the child is equal to the first char of key, do recursion with
			- substring of key starting from second char
			- exactMatchOnly, whatever original value it had
			- pointer to the correct child node
			- vector reference
			- false for isFirst
		- else, for the other children nodes whose labels aren't equal to the first char of key
		  do recursion with
			- substring of key starting from second char
			- TRUE, because if this char was not an exact match, then every following char
			  must be
			- pointer to the correct child node
			- vector reference
			- false for isFirst

GenomeMatcher::findGenomesWithThisDNA()
- This one I had much less fun with
- return false immediately if 1. minimumLength < minimumSearchLength or 2. the length of the fragment
  we're searching for is shorter than the minimumLength
- run Trie::find() to get the vector of the genome and position of match
	- NOTE: I used a string for my Trie
- clear out the vector parameter in case some person decides that it's a good idea to pass in a vector
  that already has stuff in it, then take points off because the vector contains something that isn't
  supposed to be there
- going back to the vector we got from Trie::find(), run through that
	- since I used strings for my Tries, I had to convert the digit portions back into ints
- for each item in the Trie::find() vector, extract a fragment.size() substring if possible, or else
  extract as much as possible (for example, at the end of the sequence this might happen)
- doStuff(). Nuff said. 
	- I'm just kidding, I'll explain. 
	- Run through the extracted substring and the fragment and compare each char, counting how many
	  matching chars there are
		- I wrote it slightly inefficiently because I'm also comparing the beginning parts of
		  the sequence, which I already know are the some because that's how the Trie gave me
		  their location
		- Note: There's also a bool exactMatch that lets one char be off if exactMatchOnly was
		  false
	- If the length of matching chars is less than minimumLength, return
	- Run through the vector parameter, checking to see if it already contains a DNAMatch object
	  with the same genomeName as te one we're about to insert
		- If yes, compare the length and position of the objects
		- If no, insert a new DNAMatch object with the name, length, and position
- If no matches, return false :(
- Otherwise, return true because yay, we got some matches!
	- Note: I don't believe it was specified that the matches had to be in any particular order
	  for this one, but maybe I'm wrong because there are a lot of words. 